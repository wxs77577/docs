---
permalink: lucid
title: Lucid模型
category: lucid
---
= Lucid 模型

toc::[]

Lucid是Javascript中 link:https://en.wikipedia.org/wiki/Active_record_pattern[Active Record, window="_blank"]模式的一个实现。 如果你来自 *Laravel* 或 *Rails* 世界，那么你可能对它很熟悉。

== 介绍
在编写普通数据库查询时使用模型的原因是易用性和强大的API来驱动数据流。引擎盖下的Lucid模型需要照顾

1. 吸引人的是, 透明实例模型的持久化
2. 富有表现力的API来管理关系
+
[source, javascript]
----
class User extends Model {

  profile () {
    return this.hasOne('App/Models/Profile')
  }

  posts () {
    return this.hasMany('App/Models/Post')
  }

}
----
3. 定义生命周期钩子以保持代码精简。
4. Getters/Setters可以即时改变数据。
5. 使用 *序列化器*,*计算属性* 等序列化数据。
6. 管理日期格式。
7. 还有更多。

NOTE: Lucid模型并不依赖于您的数据库模式，而是自己管理所有东西。 +
*例如*: 使用Lucid关联时，不需要在SQL中定义关联。

Lucid模型作为ES6类存储在 `app/Models` 目录中,其中每个模型表示一个数据库表。例如
[options="header"]
|====
| Model | Database table
| User | users
| Post | posts
|====

== 基本示例
让我们来看看如何创建和使用模型来读取/写入数据库。您可以使用 `adonis` 命令来生成一个模型。

=== 创建模型
[source, bash]
----
adonis make:model User

# or with migration
adonis make:model User --migration
----

.Output
[source, bash]
----
✔ create  app/Models/User.js
----

[source, js]
----
'use strict'

const Model = use('Model')

class User extends Model {
}

module.exports = User
----

=== 提取用户
现在在路由文件中，我们使用 *User* 模型来获取所有用户。

.start/routes.js
[source, js]
----
const Route = use('Route')
const User = use('App/Models/User')

Route.get('users', async () => {
  return await User.all()
})
----

=== 创建用户

[source, js]
----
const User = use('App/Models/User')

const user = new User()

user.username = 'virk'
user.password = 'some-password'

await user.save()
----

== 惯例优于配置
Lucid模型基于某些约定做了很多工作，但是当然，您可以随意使用您的设置覆盖默认值。

==== table
表名始终是模型名称的 *小写* 和 *复数形式*。但是，您可以覆盖它定义一个getter。

[source, js]
----
class User extends Model {
  static get table () {
    return 'my_users'
  }
}
----

==== connection
默认情况下，模型使用 `config/database.js` 文件中定义的默认连接。但是，您可以为每个模型设置不同的数据库连接。

[source, js]
----
class User extends Model {
  static get connection () {
    return 'mysql'
  }
}
----

==== primaryKey
主键默认设置为 `id`。但是，您可以将不同的字段标记为主键。另外，请确保该字段的值应始终是唯一的。

[source, js]
----
class User extends Model {
  static get primaryKey () {
    return 'uid'
  }
}
----


==== createdAtColumn
用于设置时间戳创建的字段名称。你可以返回 `null` 来禁用它。


[source, js]
----
class User extends Model {
  static get createdAtColumn () {
    return 'created_at'
  }
}
----

==== updatedAtColumn
用于设置时间戳创建的字段名称。你可以返回 `null` 来禁用它。

[source, js]
----
class User extends Model {
  static get updatedAtColumn () {
    return 'updated_at'
  }
}
----

==== incrementing
Lucid假定与模型相关的每个表都有一个自动递增主键。你可以通过从递增的getter中返回 `false` 来禁用这个标志。

NOTE: 当您设置 `incrementing = false` 时，您必须确保手动设置 `primaryKeyValue`。

[source, js]
----
class User extends Model {
  static get incrementing () {
    return false
  }
}
----

==== primaryKeyValue
主键的值。当 `incrementing` 设置为false时，您只需更新此键。

[source, js]
----
const user = await User.find(1)
console.log(user.primaryKeyValue)

// when incrementing is false
user.primaryKeyValue = uuid.v4()
----

== 隐藏字段
通常你会发现自己忽略了数据库结果中的字段。例如：从JSON输出中隐藏用户的密码。手动操作在很多方面都很多余的。

1. 您将手动循环遍历行并删除键/值对。
2. 当您获取关系时，您必须遍历所有父记录，然后循环其子记录以删除键/值对。

AdonisJs通过定义模型上的可见或隐藏（一次一个）来使其更简单。

==== hidden
[source, js]
----
class User extends Model {
  static get hidden () {
    return ['password']
  }
}
----

==== visible
[source, js]
----
class Post extends Model {
  static get visible () {
    return ['title', 'body']
  }
}
----

==== setVisible/setHidden
您还可以使用以下方法为单个查询定义 `hidden/visible` 字段。

[source, js]
----
User.query().setVisible(['title', 'body']).fetch()

// or set hidden
User.query().setHidden(['password']).fetch()
----


== 日期
日期是构建数据驱动程序应用程序中最难的部分。我们希望以不同的方式存储它们，并以不同的方式显示它们，这通常需要很多手动工作。

Lucid处理日期更好，以至于你只需花最少的工作做它

=== 定义日期字段
第一步是告诉Lucid，哪些字段应该被视为日期。默认情况下，`created_at` 和 `updated_at` 的时间戳被标记为日期。

但是，你也可以定义你自己的。

[source, js]
----
class User extends Model {
  static get dates () {
    return super.dates.concat(['dob'])
  }
}
----

因此，我们在这里拉出默认标记为日期的字段，并将新日期字段推送给它并最终返回它。

=== 格式化日期字段
Lucid格式的所有日期默认为 `YYYY-MM-DD HH：mm：ss`，这是所有数据库引擎的有效格式。此外，它还为您提供了一种有条件地格式化某些或所有日期字段的方法。


NOTE: 在将模型实例保存到数据库之前调用 `formatDates` 方法。因此，确保返回值始终是您正在使用的数据库引擎的有效格式。

[source, js]
----
class User extends Model {
  static formatDates (field, value) {
    if (field === 'dob') {
      return value.format('YYYY-MM-DD')
    }
    return super.formatDates(field, value)
  }
}
----

`value` 是设置字段时的实际日期。

=== 投射日期
现在我们已将日期保存到数据库中;我们可能想要以不同的格式显示给用户。使用 `castDates` 方法可以很容易地完成。

[source, js]
----
class User extends Model {
  static castDates (field, value) {
    if (field === 'dob') {
      return `${value.fromNow(true)} old`
    }
    return super.formatDates(field, value)
  }
}
----

`value` 是一个 link:https://momentjs.com/[moment.js, window="_blank"] 实例。这意味着你可以调用任何时刻的方法来格式化日期。另外，在模型实例 *deserialized* 时调用 `castDates` 方法，这发生在调用 `toJSON` 之后。

[source, js]
----
const users = await User.all()

// converting to JSON array
const usersJSON = users.toJSON()
----

== 查询构建器
Lucid模型利用 link:query-builder[数据库查询构建器] 来运行数据库查询。您可以通过调用模型上的 `query` 方法来获取查询构建器的实例。

[source, js]
----
const User = use('App/Models/User')

const adults = await User
  .query()
  .where('age', '>', 18)
  .fetch()
----

1. 完全支持所有查询构建器方法。
2. 有了Lucid模型，你应该调用`fetch`方法来执行查询。需要在 `serializer` 的实例中返回结果(了解有关 link:serializers[序列化器] 的更多信息).

== 静态方法
Lucid模型带有一些静态方法来执行常用操作，而不使用查询构建器接口。

另外，在使用下列静态方法时，不需要调用 `fetch`。

==== find
使用主键查找记录。始终返回一条记录。

[source, js]
----
const User = use('App/Models/User')
await User.find(1)
----

==== findOrFail
与 `find` 方法相同，但在无法找到记录时抛出 `ModelNotFoundException`。

[source, js]
----
const User = use('App/Models/User')
await User.findOrFail(1)
----

==== findBy / findByOrFail
使用键/值对查找记录。返回第一个匹配的记录。

[source, js]
----
const User = use('App/Models/User')
await User.findBy('email', 'foo@bar.com')

// or
await User.findByOrFail('email', 'foo@bar.com')
----

==== first / firstOrFail
找到数据库的第一行。

[source, js]
----
const User = use('App/Models/User')
await User.first()

// or
await User.firstOrFail()
----

==== findOrCreate (属性, 值)
查找记录，如果未找到，则会创建一条新记录并立即返回。

[source, js]
----
const User = use('App/Models/User')
const user = await User.findOrCreate(
  { username: 'virk' },
  { username: 'virk', email: 'virk@adonisjs.com' }
)
----

==== pick(rows = 1)
从数据库表中选择 `x` 行数。默认情况下，它只选择 `1` 行。

[source, js]
----
const User = use('App/Models/User')
await User.pick(3)
----

==== pickInverse(rows = 1)
从最后一个数据库表中选择 `x` 行数。默认情况下，它只选择 `1` 行。

[source, js]
----
const User = use('App/Models/User')
await User.pickInverse(3)
----

==== ids
返回一个主键数组。如果主键被定义为 `uid`，那么它是 `uid's` 的数组。

[source, js]
----
const User = use('App/Models/User')
const userIds = await User.ids()
----

==== pair(lhs, rhs)
返回键/值对的对象。`lhs` 字段是对象键，`rhs` 是值。

[source, js]
----
const User = use('App/Models/User')
const users = await User.pair('id', 'country')

// returns { 1: 'ind', 2: 'uk' }
----

==== all
选择所有行

[source, js]
----
const User = use('App/Models/User')
const users = await User.all()
----

==== truncate
删除所有行（截断表）

[source, js]
----
const User = use('App/Models/User')
const users = await User.truncate()
----

== 聚合助手
link:query-builder#_aggregate_helpers[查询构建器聚合助手] 提供对常见聚合查询的快捷访问。当您希望聚合整个表格时，可以使用静态模型方法。

NOTE: 这些方法结束查询生成器链接并返回一个值。没有必要调用 `link:#_query_builder[fetch()]`.

==== getCount(列表名 = '*')
返回给定结果集中的记录数。

[source, js]
----
const User = use('App/Models/User')

// returns number
await User.getCount()
----

你也可以在调用 `getCount` 之前添加查询条件。
[source, js]
----
await User
  .query()
  .where('is_active', 1)
  .getCount()
----

就像 `getCount` 一样，您可以调用 link:query-builder#_aggregate_helpers[查询构建器] 上可用的所有聚合方法

== 查询范围
查询范围是将查询条件提取为可用且功能强大的方法的便捷方法。例如，我们想要获取所有拥有个人资料的用户

[source, js]
----
const Model = use('Model')

class User extends Model {
  static scopeHasProfile (query) {
    return query.has('profile')
  }

  profile () {
    return this.hasOne('App/Models/Profile')
  }
}
----

所以，现在你可以使用它

[source, js]
----
const users = await User.query().hasProfile().fetch()
----

查询范围的想法是让您的代码更具可读性，就好像您正在阅读纯文本一样。

1. 范围总是用一个名为 `scope` 的关键字来定义，后面跟着方法名称。
2. 使用范围时，可以通过删除 `scope` 关键字并以 *camelCase* 形式来调用该方法。
3. 您可以在查询范围内调用所有标准查询构建器方法。


== 分页
Lucid也支持来自查询构建器的 `paginate` 方法。

[source, js]
----
const User = use('App/Models/User')
const page = 1

const users = await User.query().paginate(page)

return view.render('users', { users: users.toJSON() })
----

`paginate` 的返回值不是用户数组。相反，它是一个包含元数据和 `data` 属性的对象，它具有用户列表。

[source, js]
----
{
  total: '',
  perPage: '',
  lastPage: '',
  page: '',
  data: []
}
----

== 插入 & 更新
使用模型而不是将原始值插入到数据库中，可以持久存储模型实例，然后为您插入查询。例如

[source, js]
----
const User = use('App/Models/User')

const user = new User()
user.username = 'virk'
user.email = 'foo@bar.com'

await user.save()
----

`save` 方法将实例保存到数据库中。此外，它巧妙地计算出是创建一个新行还是更新现有行。例如：

[source, js]
----
const User = use('App/Models/User')

const user = new User()
user.username = 'virk'
user.email = 'foo@bar.com'

// Insert
await user.save()

user.age = 22

// Update
await user.save()
----

只有在更新了某些内容时，才会执行 `update` 查询。而多次调用 `save`，不更新模型属性则不会执行任何查询。

可以使用 `fill` 或 `merge` 方法，而不是手动设置属性。

`fill` 方法将覆盖模型实例的所有现有键/值对。

[source, js]
----
const User = use('App/Models/User')

const user = new User()
user.username = 'virk'
user.age = 22

user.fill({ age: 23 }) // remove existing values, only set age.

await user.save()

// returns { age: 23, username: null }
----

`merge` 方法只修改指定的属性

[source, js]
----
const User = use('App/Models/User')

const user = new User()
user.fill({ username: 'virk', age: 22 })

user.merge({ age: 23 })

await user.save()

// returns { age: 23, username: 'virk' }
----

==== create
或者，您也可以将一堆数据直接提供给模型实例，而不是手动设置属性。

[source, js]
----
const User = use('App/Models/User')
const userData = request.only(['username', 'email', 'age'])

// save and get instance back
const user = await User.create(userData)
----

==== createMany
就像 `create` 一样，您可以使用createMany方法持久化模型的多个实例。

NOTE: `createMany` 方法生成 *n* 个查询，而不是执行批量插入，其中 *n* 是行数。

[source, js]
----
const User = use('App/Models/User')
const usersData = request.collect(['username' 'email', 'age'])

const users = await User.createMany(usersData)
----

=== 批量更新
批量更新可以在查询构建器的帮助下完成。 Lucid确保在进行批量更新时相应地格式化日期。

*批量更新从不执行任何模型挂钩。*

[source, js]
----
const User = use('App/Models/User')

await User
  .query()
  .where('username', 'virk')
  .update({ role: 'admin' })
----

== 删除
通过调用delete方法可以删除单个模型实例。

[source, js]
----
const User = use('App/Models/User')

const { id } = params
const user = await User.find(id)

await user.delete()
----

调用 `delete` 方法后，模型实例会停止任何更新，但您仍然可以从中读取数据。

[source, js]
----
await user.delete()

console.log(user.id) // works fine

user.id = 1 // throws exception
----

=== 批量删除
批量删除可以在查询构建器的帮助下完成。

*批量删除从不执行任何模型挂钩。*

[source, js]
----
const User = use('App/Models/User')

await User
  .query()
  .where('role', 'guest')
  .delete()
----

== 交易
Lucid方法的大部分都支持交易。第一步是使用数据库提供者来获取 `trx` 对象。

[source, js]
----
const trx = await Database.beginTransaction()

const user = new User()

// pass the trx object and lucid will use it
await user.save(trx)

// once done commit the transaction
trx.commit()
----

就像 `save` 一样，您也可以将 `trx` 对象传递给 `create` 方法。

[source, js]
----
const trx = await Database.beginTransaction()

await User.create({ username: 'virk' }, trx)

// once done commit the transaction
trx.commit()
----

[source, js]
----
await User.createMany([
  { username: 'virk' }
], trx)
----

== 引导周期
每个模型都有一个引导周期，在引导周期中引导，并且只发生一次。所以如果你想执行一次应该只发生一次的事情，可以考虑在 `boot` 方法中写入它。
[source, js]
----
const Model = use('Model')

class User extends Model {
  static boot () {
    super.boot()

    /**
      I will be called only once
    */
  }
}

module.exports = User
----
